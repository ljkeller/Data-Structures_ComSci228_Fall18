package edu.iastate.cs228.hw02;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. *  * @author Frank M. Carrano * @author Timothy M. Henry * @aughor Lucas Keller * @version 4.1 */public final class LinkedBag<T> implements BagInterface<T> {	private Node firstNode; // Reference to first node	private int numberOfEntries;	public LinkedBag() {		firstNode = null;		numberOfEntries = 0;	} // end default constructor	/**	 * Sees whether this bag is empty.	 * 	 * @return True if this bag is empty, or false if not.	 */	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return The integer number of entries currently in this bag.	 */	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            The object to be added as a new entry	 * @return True if the addition is successful, or false if not.	 */	public boolean add(T newEntry) // OutOfMemoryError possible	{		// Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode; // Make new node reference rest of chain									// (firstNode is null if chain is empty)		firstNode = newNode; // New node is at beginning of chain		numberOfEntries++;		return true;	} // end add	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return A newly allocated array of all the entries in this bag.	 */	public Object[] toArray() {		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[numberOfEntries]; // Unchecked cast		int index = 0;		Node currentNode = firstNode;		while ((index < numberOfEntries) && (currentNode != null)) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		} // end while		return result;	} // end toArray	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry	 *            The entry to be counted.	 * @return The number of times anEntry appears in this bag.	 */	public int getFrequencyOf(T anEntry) {		int frequency = 0;		int counter = 0;		Node currentNode = firstNode;		while ((counter < numberOfEntries) && (currentNode != null)) {			if (anEntry.equals(currentNode.data)) {				frequency++;			} // end if			counter++;			currentNode = currentNode.next;		} // end while		return frequency;	} // end getFrequencyOf	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            The entry to locate.	 * @return True if the bag contains anEntry, or false otherwise.	 */	public boolean contains(T anEntry) {		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while		return found;	} // end contains	// Locates a given entry within this bag.	// Returns a reference to the node containing the entry, if located,	// or null otherwise.	private Node getReferenceTo(T anEntry) {		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while		return currentNode;	} // end getReferenceTo	/** Removes all entries from this bag. */	public void clear() {		while (!isEmpty())			remove();	} // end clear	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return Either the removed entry, if the removal was successful, or null.	 */	public T remove() {		T result = null;		if (firstNode != null) {			result = firstNode.data;			firstNode = firstNode.next; // Remove first node from chain			numberOfEntries--;		} // end if		return result;	} // end remove	/**	 * Removes one occurrence of a given entry from this bag, if possible.	 * 	 * @param anEntry	 *            The entry to be removed.	 * @return True if the removal was successful, or false otherwise.	 */	public boolean remove(T anEntry) {		boolean result = false;		Node nodeN = getReferenceTo(anEntry);		if (nodeN != null) {			nodeN.data = firstNode.data; // Replace located entry with entry in first node			firstNode = firstNode.next; // Remove first node			numberOfEntries--;			result = true;		} // end if		return result;	} // end remove	@Override	public BagInterface<T> union(BagInterface<T> anotherBag) {		LinkedBag<T> unionBag = new LinkedBag<T>();		int counter = 0;		// create current node for iterating		Node currentNode = this.firstNode;		// first add this bag linearly		while (counter < this.numberOfEntries && currentNode != null) {			unionBag.add(currentNode.data);			currentNode = currentNode.next;			counter++;		}		counter = 0;		// must cast anotherBag to LinkedBag to use firstNode.next		currentNode = ((LinkedBag<T>) anotherBag).firstNode;		while (counter < anotherBag.getCurrentSize() && currentNode != null) {			unionBag.add(currentNode.data);			currentNode = currentNode.next;			counter++;		}		return unionBag;	}	@Override	public BagInterface<T> intersection(BagInterface<T> anotherBag) {		LinkedBag<T> intersectionBag = new LinkedBag<T>();		Node currentNode = this.firstNode;		int counter = 0;		/*		 * must go through current Bag THEN check for commonalities, Only have to go		 * through current bag because items in other bag not in this one will not be		 * considered common anyways		 */		while (currentNode != null && counter < this.getCurrentSize()) {			// search for commonalities between bagss, add to bag one by one until reached			// common amount			while (intersectionBag.getFrequencyOf(currentNode.data) < Math.min(this.getFrequencyOf(currentNode.data),					anotherBag.getFrequencyOf(currentNode.data))) {				intersectionBag.add(currentNode.data);			}			// interate node and safety counter			counter++;			currentNode = currentNode.next;		} // end while loop		return intersectionBag;	}	@Override	public BagInterface<T> difference(BagInterface<T> anotherBag) {		LinkedBag<T> differenceBag = new LinkedBag<T>();		int counter = 0;		Node currentNode = this.firstNode;		// goes through thisBag node by node		while (currentNode != null && counter < this.getCurrentSize()) {			/*			 * between current node iterations, must add to the difference bag the item an			 * amount of times equal to the difference between thisBag and anotherBag			 */			while (differenceBag.getFrequencyOf(currentNode.data) < this.getFrequencyOf(currentNode.data)					- anotherBag.getFrequencyOf(currentNode.data)) {				differenceBag.add(currentNode.data);			}			// iterate			counter++;			currentNode = currentNode.next;		}		return differenceBag;	}	@Override	public T replace(T replacement) {		if (this.getCurrentSize() == 0)			return null;		// temporarily hold the first nodes data before its replaces		T tempDataHolder = firstNode.data;		// reassign		this.firstNode.data = replacement;		return tempDataHolder;	}	@Override	public void removeEvery(T anEntry) {		// check if entry is there first		while (this.getFrequencyOf(anEntry) > 0) {			this.remove(anEntry);		}	}	@Override	public boolean equals(Object compare) {		Node currentNode = firstNode;		int counter = 0;		LinkedBag<T> tempBagCast = ((LinkedBag<T>) compare);		// quick checks for null & different classes or sizes		if (compare == null || compare.getClass() != this.getClass()				|| this.getCurrentSize() != ((LinkedBag<T>) compare).getCurrentSize())			return false;		// quick check for same reference points		if (this.firstNode == ((LinkedBag<T>) compare).firstNode)			return true;		// If made it this far, must check contents by checking frequency		while (currentNode != null && counter < this.getCurrentSize()) {			if (tempBagCast.getFrequencyOf(currentNode.data) != this.getFrequencyOf(currentNode.data))				return false;			// iterate counter and node			currentNode = currentNode.next;			counter++;		}		return true;	}	private class Node {		private T data; // Entry in bag		private Node next; // Link to next node		private Node(T dataPortion) {			this(dataPortion, null);		} // end constructor		private Node(T dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		} // end constructor	} // end Node} // end LinkedBag