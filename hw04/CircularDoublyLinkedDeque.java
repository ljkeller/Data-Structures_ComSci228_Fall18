package edu.iastate.cs228.hw04;/** *  * @author Lucas Keller *  *         NOTE: 0. Put your Firstname and Lastname after above author tag. Make *         sure that in both cases the first letter is uppercase and all others *         are lowercase (and a space). 1. You are allowed to create and use *         your own private helper methods. 2. No additional data fields can be *         introduced. 3. No custom classes of your own can be introduced or *         used. 4. Import statements are not allowed. 5. Fully qualified class *         names usage is not allowed. 6. You are allowed to reuse any part of *         the source codes provided or shown in lecture notes of week 5 (or *         before). 7. You are not allowed to create arrays of objects and *         manipulate queue objects using arrays. * * *         DESCRIPTION: A class that implements the ADT deque by using a *         "circular doubly linked chain" of nodes. In doubly linked chain, the *         first and last nodes each contain one null reference, since the first *         node has no previous node and the last node has no node after it. *         (For details of doubly linked chain implementation of deque, check *         slide number 3 of "queueDequePriorityQueueImplementations_part3.pdf" *         file under lecture notes of Friday of Week 5 on Canvas.) In a *         "circular doubly linked chain", the first node references the last *         node, and the last node references the first. Only one external *         reference is necessary - a reference to the first node - since you *         can quickly get to the last node from the first node. *  */public class CircularDoublyLinkedDeque<T> implements DequeInterface<T> {	private DLNode firstNode; // References node for front of deque	public CircularDoublyLinkedDeque() {		firstNode = null;	} // end default constructor	/**	 * Adds entry to back of deque	 * 	 * @param newEntry	 *            A new entry for the deque	 */	public void addToBack(T newEntry) {		if (firstNode == null) { // if deque is empty			firstNode = new DLNode(null, newEntry, null);			firstNode.setNextNode(firstNode);			firstNode.setPreviousNode(firstNode);		} else {			DLNode frontNode = new DLNode(firstNode.getPreviousNode(), newEntry, firstNode);			firstNode.getPreviousNode().setNextNode(frontNode); // reassign next node of last node			firstNode.setPreviousNode(frontNode); // reassign previous node of previous first		}	}	/**	 * Adds new entry to front of deque	 * 	 * @param newEntry	 *            A new entry for the deque	 */	public void addToFront(T newEntry) {		if (firstNode == null) { // if deque is empty			firstNode = new DLNode(null, newEntry, null);			firstNode.setNextNode(firstNode);			firstNode.setPreviousNode(firstNode);		} else {			DLNode frontNode = new DLNode(firstNode.getPreviousNode(), newEntry, firstNode);			firstNode.getPreviousNode().setNextNode(frontNode); // reassign next node of last node			firstNode.setPreviousNode(frontNode); // reassign previous node of previous first			firstNode = firstNode.getPreviousNode();		}			}	/**	 * Retrieves the front entry of this dequeue.	 * 	 * @return The object at the front of the dequeue.	 * @throws EmptyQueueException	 *             if the dequeue is empty before the operation.	 */	public T getFront() {		if (firstNode == null)			throw new EmptyQueueException();		else {			return firstNode.getData();		}	}	/**	 * Retrieves the back entry of this dequeue.	 * 	 * @return The object at the back of the dequeue.	 * @throws EmptyQueueException	 *             if the dequeue is empty before the operation.	 */	public T getBack() {		if (firstNode == null)			throw new EmptyQueueException();		else {			return firstNode.getPreviousNode().getData();		}	}	/**	 * Removes and returns the front entry of this dequeue.	 * 	 * @return The object at the front of the dequeue.	 * @throws EmptyQueueException	 *             if the dequeue is empty before the operation.	 */	public T removeFront() {		if (firstNode == null) {			throw new EmptyQueueException();		} else if (firstNode.getNextNode() == firstNode) {			T temp = firstNode.getData();			firstNode = null;			return temp;		} else {			T temp = firstNode.getData();			firstNode.getPreviousNode().setNextNode(firstNode.getNextNode());			firstNode.getNextNode().setPreviousNode(firstNode.getPreviousNode());			firstNode = firstNode.getNextNode();			return temp;		}	}	/**	 * Removes and returns the back entry of this dequeue.	 * 	 * @return The object at the back of the dequeue.	 * @throws EmptyQueueException	 *             if the dequeue is empty before the operation.	 */	public T removeBack() {		if (firstNode == null) {			throw new EmptyQueueException();		} else if (firstNode.getNextNode() == firstNode) {			T temp = firstNode.getData();			firstNode = null;			return temp;		} else {			T temp = firstNode.getPreviousNode().getData();			firstNode.getPreviousNode().getPreviousNode().setNextNode(firstNode);			firstNode.setPreviousNode(firstNode.getPreviousNode().getPreviousNode());									return temp;		}	}	/** Removes all entries from this dequeue. */	public void clear() {		firstNode = null;	}	/**	 * Detects whether this dequeue is empty.	 * 	 * @return True if the queue is empty, or false otherwise.	 */	public boolean isEmpty() {		return firstNode == null;	}	private class DLNode {		private T data; // Deque entry		private DLNode next; // Link to next node		private DLNode previous; // Link to previous node		private DLNode() {			this(null, null, null);		} // end default constructor		private DLNode(T dataPortion) {			this(null, dataPortion, null);		} // end constructor		private DLNode(DLNode previousNode, T dataPortion, DLNode nextNode) {			data = dataPortion;			next = nextNode;			previous = previousNode;		} // end constructor		private T getData() {			return data;		} // end getData		private void setData(T newData) {			data = newData;		} // end setData		private DLNode getNextNode() {			return next;		} // end getNextNode		private void setNextNode(DLNode nextNode) {			next = nextNode;		} // end setNextNode		private DLNode getPreviousNode() {			return previous;		} // end getPreviousNode		private void setPreviousNode(DLNode previousNode) {			previous = previousNode;		} // end setPreviousNode	} // end DLNode} // end CircularDoublyLinkedDeque