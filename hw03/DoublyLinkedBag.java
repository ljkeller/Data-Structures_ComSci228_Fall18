package edu.iastate.cs228.hw03;/** * A class of bags whose entries are stored in a chain of doubly linked nodes. *  * @author Lucas Keller *  */public class DoublyLinkedBag<T> implements BagInterface<T> {	private DoublyLinkedNode firstNode; // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag() {		firstNode = null;		numberOfEntries = 0;	} // end default constructor	public boolean add(T newEntry) {		DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry, firstNode, null);		numberOfEntries++;		if (firstNode != null) {			firstNode.prev = newNode;		}		firstNode = newNode;		return true;	} // end add	public T[] toArray() {		@SuppressWarnings("unchecked")		T[] tempArray = (T[]) new Object[numberOfEntries];		// safetyCounter		int counter = 0;		DoublyLinkedNode tempNode = firstNode;		// Enter data into array, iterate index then node		while (counter < numberOfEntries && tempNode != null) {			tempArray[counter] = tempNode.data;			counter++;			tempNode = tempNode.next;		}		return tempArray;	} // end toArray	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) {		int frequencyCounter = 0;		DoublyLinkedNode iteratorNode = firstNode;		int counter = 0;		if (getCurrentSize() == 0 || firstNode == null)			return 0;		while (counter < getCurrentSize() && iteratorNode != null) {			if (iteratorNode.data == anEntry)				frequencyCounter++;			counter++;			iteratorNode = iteratorNode.next;		}		return frequencyCounter;	} // end getFrequencyOf	public boolean contains(T anEntry) {		DoublyLinkedNode iteratorNode = firstNode;		int counter = 0;		while (counter < getCurrentSize() && iteratorNode != null) {			if (iteratorNode.data == anEntry)				return true;			counter++;			iteratorNode = iteratorNode.next;		}		return false;	} // end contains	public void clear() {		while (!isEmpty()) {			remove();		}	} // end clear	public T remove() {		T result = null;		if (numberOfEntries > 0) {			numberOfEntries--;			result = firstNode.data;			if (firstNode.next == null) {				firstNode = null;				return result;			}			firstNode = firstNode.next;			firstNode.prev = null;		}		return result;	} // end remove	public boolean remove(T anEntry) {		boolean result = false;		DoublyLinkedNode iteratorNode = firstNode;		int counter = 0;		while (counter < getCurrentSize() && iteratorNode != null) {			if (iteratorNode.data == anEntry) {				iteratorNode.data = firstNode.data;				remove();				return true;			}			// set previous node reference to next node reference. Poof, this node is gone;			iteratorNode = iteratorNode.next;		}		return result;	} // end remove	public T replace(T replacement) {		T tempData = null;		if (getCurrentSize() > 0) {			tempData = firstNode.data;			firstNode.data = replacement;		}		return tempData;	}	public void removeEvery(T anEntry) {		while (getFrequencyOf(anEntry) > 0)			remove(anEntry);	}	/**	 * Override the equals method of Object class so that it returns true when the	 * contents of two DoublyLinkedBags are same. Note that two equal	 * DoublyLinkedBags contain the same number of entries, and each entry occurs in	 * each DoublyLinkedBag the same number of times. I.e., the elements in two do	 * not need to be in exact same location.	 * 	 * Before checking the contents inside this method make sure that the passed in	 * object is not null, is of the same runtime class, and the lengths are same.	 * If any of these fail you can return false. Otherwise, you base your return	 * results on contents. (At the start you can also do the quick check if both	 * refer to the same object in memory.)	 */	@Override	public boolean equals(Object obj) {		if (obj == null || this.getClass() != obj.getClass())			return false;		else if (this.numberOfEntries != ((DoublyLinkedBag<T>) obj).numberOfEntries)			return false;		else if(this == obj)			return true;		else {			DoublyLinkedNode iteratorNode = firstNode;			int counter = 0;			while (counter < getCurrentSize() && iteratorNode != null) {				if (this.getFrequencyOf(iteratorNode.data) != ((DoublyLinkedBag<T>) obj)						.getFrequencyOf(iteratorNode.data))					return false;				counter++;				iteratorNode = iteratorNode.next;			}		}		return true;	}	/**	 * Returns String representation of the items in this bag. For example, it would	 * return [A, B, C] if bag had three Strings "A", "B", and "C".	 * 	 * @return String representation of items in this bag enclosed in square	 *         brackets, separated by comma and a single space (see example above).	 *         You can rely on the fact that items' proper toString method was	 *         implemented. In this method ONLY if you need to you can use String	 *         class's methods. Also, ONLY in this method you can use fully	 *         qualified name for StringBuffer class, and use all of its methods.	 */	@Override	public String toString() {		String bagContents = "[";		DoublyLinkedNode iteratorNode = firstNode;		int counter = 0;		if (numberOfEntries == 0)			return "[]"; // this is returned in case bag is empty.		else			while (counter < numberOfEntries && iteratorNode.next != null) {				bagContents += "" + iteratorNode.data.toString() + ", ";				counter++;				iteratorNode = iteratorNode.next;			}		bagContents += iteratorNode.data.toString() + "]";		return bagContents;	}	// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode {		private T data; // Entry in bag		private DoublyLinkedNode next; // Link to next node		private DoublyLinkedNode prev; // Link to previous node		private DoublyLinkedNode(T dataPortion) {			this(dataPortion, null, null);		} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode, DoublyLinkedNode previousNode) {			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor	} // end DoublyLinkedNode} // end DoublyLinkedBag